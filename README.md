# Основы работы Git

Чтобы вы понимали важность знания гита в наше время, скажу так - без знания/понимания этого вам делать в программировании нечего. Но прелесть в том, что для постоянной работы не нужно держать в голове все команды и возможности. Нужно знать набор команд, которые помогут понимать всё, что происходит. В сети доступен .

## Команда Git

Давайте рассмотрим основные опции и параметры команды:

```
git опции команда аргументы
```

Опции

-   `-C`  использовать указанную папку репозитория вместо текущей папки
-   `-c параметр=значение`  использовать указанное значение параметра конфигурации
-   `-p`  прокручивать весь вывод с помощью less

Команды

-   `add`  добавить файл или папку в репозиторий git
-   `am`  применить все патчи из email
-   `archive`  создать архив файлов
-   `bisect`  использовать бинарный поиск для поиска нужного коммита
-   `branch`  управление ветками проекта
-   `bundle`  перемещение объектов и ссылок в архиве
-   `checkout`  переключение между ветками
-   `cherry-pick`  внести изменения в уже существующие коммиты
-   `clean`  удалить все неотслеживаемые файлы и папки проекта
-   `clone`  создать копию удаленного репозитория в папку
-   `commit`  сохранить изменения в репозиторий
-   `diff`  посмотреть изменения между коммитами
-   `fetch`  скачать удаленный репозиторий
-   `init`  создать репозиторий
-   `merge`  объединить две ветви
-   `pull`  интегрировать удаленный репозиторий с локальным
-   `push`  отправить изменения в удаленный репозиторий
-   `tag`  управление тегами
-   `worktree`  управление деревями разработки

Аргументы

Аргументы зависят от используемой команды.

## Этапы работы

Дальше предположительно должна быть выполнина установка и базовая настройка Git. Всю работу можно разделить на этапы:

1.  `git init`  перед тем как git начнет отслеживать изменения, нужно подготовить все необходимые конфигурационные файлы
2.  `git add .`  добавляем отслеживаемые файлы, по отдельности или сказать утилите, что необходимо добавить все файлы явно
3.  `git commit -m "название_комита"`  фиксация изменений с помощью создание нового коммита
4.  `git branch название_новой_ветки`  на основе коммита создается ветка для ветвления проекта (не обязательно)
5.  `git push origin название_ветки`  для обмена информацией с другими разработчиками и сохранения данных в облаке, отправляем данные в удаленный репозиторий (не обязательно)

## Основные термины

`Репозиторий`  каталог файловой системы, в котором находятся: файлы конфигурации, файлы журналов операций, выполняемых над репозиторием, индекс расположения файлов и хранилище, содержащее сами контролируемые файлы.

`Локальный репозиторий`  репозиторий, расположенный на локальном компьютере разработчика в каталоге. Именно в нём происходит разработка и фиксация изменений, которые отправляются на удаленный репозиторий.

`Удаленный репозиторий`  репозиторий, находящийся на удаленном сервере. Это общий репозиторий, в который приходят все изменения, и из которого забираются все обновления.

`Коммит (Commit)`  зафиксированное состояние репозитория.  
У коммита есть метаданные: идентификатор, имя автора, дата создания, комментарий.

`Ветка (Branch)`  это отдельная история изменений (коммитов) в рамках одного репозитория. Git поощряет создание отдельных веток для каждой решаемой задачи, благодаря чему и достигается эффективная параллельная работа — каждый разработчик может работать со своей историей и не бояться, что изменения в чужом коде повлияют на его работу

`Слияние (Merge)`  слияние изменений из какой-либо ветки репозитория с любой веткой этого же репозитория.

`Клонирование (Clone)`  скачивание репозитория с удаленного сервера на локальный компьютер в определённый каталог для дальнейшей работы с этим каталогом как с репозиторием.

`Пул (Pull)`  получение последних изменений с удалённого сервера репозитория.

`Пуш (Push)`  отправка всех неотправленных коммитов на удалённый сервер репозитория.




# Основные команды

## git init

Команда  `git init`  используется для создания нового локального репозитория Git. После выполнения этой команды Git создает в текущей директории новую поддиректорию с именем  `.git`, в которой хранятся все файлы Git, необходимые для управления версиями в этом репозитории. Синтаксис команды:

```
git init [--bare] [<directory>]
```

`directory`  указывает директорию, в которой создается локальный репозиторий. Если параметр не указан, репозиторий создается в текущей директории.

Основные флаги:

-   `--template`  позволяет указать кастомный шаблон инициализации
-   `--separate-git-dir`  позволяет разместить репозиторий в другой директории
-   `--bare`  определяет репозиторий как голый, без рабочей директории. Это используется для создания удаленного репозитория

Примеры использования.

```
cd my_project
git init
```

Эта команда создает новый локальный репозиторий Git в текущей директории  `my_project`. Git создает поддиректорию  `.git`  и инициализирует ее файлами, необходимыми для управления версиями.

Флаг  `--bare`  используется для создания голого удаленного репозитория:

```
mkdir my_repo.git
cd my_repo.git
git init --bare
```

Эта команда создает новый удаленный репозиторий Git в директории  `my_repo.git`. Флаг  `--bare`  указывает, что это голый репозиторий, без рабочей директории.

## git clone

Команда  `git clone`  используется для создания локальной копии удаленного репозитория Git. Это позволяет вам получить копию проекта на вашем локальном компьютере и начать работу с ним. Синтаксис команды:

```
git clone <URL репозитория> [<название локальной папки>]
```

Где  `URL репозитория`  это URL-адрес удаленного репозитория Git, а  `название локальной папки`  (необязательный параметр) это название локальной папки, в которую будет склонирован репозиторий. Если  `название локальной папки`  не указан, Git автоматически создаст папку с названием репозитория.

Примеры использования.

```
git clone https://github.com/username/repo.git
```

Эта команда создаст локальную копию удаленного репозитория  `repo`, который находится в аккаунте  `username`  на GitHub, в папке с названием  `repo`.

Если вы хотите указать свое собственное название для локальной папки, вы можете добавить его после URL-адреса репозитория:

```
git clone https://github.com/username/repo.git myproject
```

Эта команда создаст локальную копию удаленного репозитория  `repo`  в папке  `myproject`. Если папка  `myproject`  уже существует, Git выведет сообщение об ошибке и не склонирует репозиторий.

## git status

Команда  `git status`  используется для получения информации о текущем состоянии вашего рабочего пространства Git. Она показывает, какие файлы были изменены, какие из них были добавлены в индекс, и какие из них готовы к коммиту. Кроме того, команда  `git status`  сообщает о текущей ветке и другой полезной информации. Синтаксис команды:

```
git status [-s] [--long] [--branch] [--porcelain] [--ignore-submodules[=<when>]]
```

Основные флаги:

-   `-s`  или  `--short`  показывает краткую информацию о состоянии файлов в формате  `git diff --shortstat`
-   `--long`  показывает длинный формат состояния файлов, включая информацию о последнем коммите для каждого файла
-   `--branch`  показывает текущую ветку и ее состояние
-   `--porcelain`  показывает состояние файлов в машинно-читаемом формате, что полезно для автоматизации
-   `--ignore-submodules`  позволяет игнорировать изменения в подмодулях

Примеры использования.

```
$ git status
На ветке main
Ваша ветка опережает «origin/main» на 1 коммит.
  (используйте «git push», чтобы опубликовать локальные коммиты)
изменения, которые будут включены в коммит:
  (используйте «git restore --staged <file>...», чтобы убрать из индекса)
        изменён:   README.md
изменения, которые не проиндексированы для коммита:
  (используйте «git add <file>...», чтобы проиндексировать)
        изменён:   index.html
нет изменений добавленных для коммита (используйте «git add» и/или «git commit -a»)
```

Эта команда показывает, что находитесь на ветке  `main`, ваша локальная ветка опережает ветку  `origin/main`  на один коммит и что были внесены изменения в файлы  `README.md`  и  `index.html`. Файл  `README.md`  был проиндексирован и готов к коммиту, а файл  `index.html`  не был проиндексирован. Для того, чтобы проиндексировать файл  `index.html`, нужно использовать команду  `git add index.html`.

## git diff

Команда  `git diff`  используется для просмотра различий между версиями файлов в репозитории. Она показывает, какие изменения были сделаны в файлах с момента последнего коммита. Синтаксис команды:

```
git diff [<опции>] [<источник>] [<цель>]
```

Где  `источник`  определяет начальную точку изменений для отображения различий.  `цель`  определяет конечную точку изменений для отображения различий.  `опции`  дополнительные флаги, изменяющие поведение команды.

Основные флаги:

-   `--cached`  сравнивает изменения между вашим индексом (т.е. тем, что будет в следующем коммите) и последним коммитом
-   `--stat`  показывает статистику изменений для каждого файла
-   `--color`  отображает различия с использованием цветов для лучшей читаемости

Примеры использования.

```
git diff - простой запуск команды покажет различия между вашей рабочей копией и последним коммитом
git diff --cached - покажет различия между вашим индексом и последним коммитом
git diff HEAD - покажет различия между вашей рабочей копией и последним коммитом
git diff HEAD~2 HEAD - покажет различия между двумя последними коммитами
git diff --stat - покажет статистику изменений для каждого файла
git diff --color - покажет различия с использованием цветов
```

Кроме того, можно использовать  `git diff`  для сравнения любых двух коммитов, веток или тэгов в репозитории. Например,  `git diff branch1 branch2`  покажет различия между двумя ветками  `branch1`  и  `branch2`.

## git log

Команда  `git log`  используется для просмотра истории коммитов в репозитории Git. Она отображает список коммитов в обратном хронологическом порядке, начиная с последнего. Синтаксис команды:

```
git log
```

Эта команда показывает список всех коммитов в репозитории, от самых последних до самых старых. Каждый коммит включает SHA-1 хеш, автора коммита, дату и время коммита, комментарий.

Основные флаги команды:

-   `--oneline`  показывает каждый коммит в одной строке, содержащей только его SHA-1 хеш и комментарий
-   `--graph`  показывает историю коммитов в виде графа, что позволяет легко визуализировать разветвленную историю ветвлений и слияний
-   `--author=<имя>`  показывает только коммиты, сделанные указанным автором
-   `--since=<дата>`  показывает только коммиты, сделанные после указанной даты
-   `--until=<дата>`  показывает только коммиты, сделанные до указанной даты
-   `-n <количество>`  показывает только указанное количество последних коммитов
-   `--grep=<строка>`  показывает только коммиты, содержащие указанную строку в своих комментариях

Примеры использования.

Пример использования флага  `--since`:

```
git log --since=2022-01-01
```

Эта команда показывает список всех коммитов, сделанных после 1 января 2022 года.

Пример использования флага  `--author`:

```
git log --author="John Doe"
```

Эта команда показывает список всех коммитов, сделанных автором с именем "John Doe".

Пример использования флага  `--grep`:

```
git log --grep="bug"
```

Эта команда показывает список всех коммитов, содержащих слово "bug" в своих комментариях.

## git pull

Команда  `git pull`  используется для получения изменений из удаленного репозитория и объединения их с вашей локальной веткой. Синтаксис команды:

```
git pull [<options>] [<repository> [<refspec>]]
```

Основные флаги:

-   `--rebase`  выполняет перебазирование текущей ветки на самый новый коммит вместо создания слияния  `merge`. Рекомендуется использовать этот флаг, если вы хотите, чтобы история коммитов оставалась простой и понятной
-   `--no-rebase`  отменяет перебазирование и выполняет слияние вместо этого
-   `--no-commit`  предотвращает создание автоматического коммита после выполнения слияния. Это дает возможность внести дополнительные изменения перед фиксацией изменений
-   `--ff-only`  выполнить слияние только в том случае, если это можно сделать быстрым перемещением ветки вперед  `fast-forward`
-   `--no-ff`  выполнить слияние только как коммит слияния  `merge commit`, даже если это можно сделать быстрым перемещением ветки вперед

Примеры использования.

Простой  `git pull`, который получает изменения из удаленной ветки и автоматически объединяет их с локальной веткой:

```
git pull
```

`git pull`  с использованием флага  `--rebase`, который перебазирует текущую ветку на самый новый коммит из удаленной ветки вместо создания слияния:

```
git pull --rebase
```

`git pull`  с использованием флага  `--no-commit`, который предотвращает создание автоматического коммита после выполнения слияния:

```
git pull --no-commit
```

`git pull`  с использованием флага  `--ff-only`, который выполнит слияние только в том случае, если это можно сделать быстрым перемещением ветки вперед  `fast-forward`:

```
git pull --ff-only
```

`git pull`  с использованием флага  `--no-ff`, который выполнит слияние только как коммит слияния  `merge commit`, даже если это можно сделать быстрым перемещением ветки вперед:

```
git pull --no-ff
```

## git push

Команда  `git push`  используется для отправки изменений из вашего локального репозитория в удаленный репозиторий Git. Это позволяет обновить содержимое удаленного репозитория на основе ваших локальных изменений. Синтаксис команды:

```
git push <remote> <branch>
```

`emote`  имя удаленного репозитория, куда вы хотите отправить изменения, а  - это название ветки, которую вы хотите отправить.

Основные флаги:

-   `-u`  или  `--set-upstream`  устанавливает отслеживание для ветки, что позволяет вам использовать  `git push`  и  `git pull`  без указания имени удаленного репозитория и названия ветки
-   `-f`  или  `--force`  заставляет Git принудительно заменить удаленную ветку измененной локальной веткой, даже если это приведет к потере данных
-   `-n`  или  `--dry-run`  позволяет вам протестировать команду  `git push`, не отправляя реальных изменений в удаленный репозиторий
-   `-v`  или  `--verbose`  выводит дополнительную информацию о процессе отправки изменений

Примеры использования.

```
git push origin main
```

Эта команда отправляет изменения из вашей локальной ветки  `main`  в удаленный репозиторий с именем  `origin`.

Пример использования команды:

```
git push -u origin main
```

Эта команда отправляет изменения из вашей локальной ветки  `main`  в удаленный репозиторий с именем  `origin`  и устанавливает отслеживание для этой ветки.

## git add

Команда  `git add .`  используется для добавления изменений в индекс Git. Индекс - это промежуточный слой между рабочей директорией (где находятся ваши файлы) и репозиторием Git (где сохраняются изменения). Когда вы делаете изменения в файлах в рабочей директории, они не автоматически добавляются в индекс. Для того, чтобы добавить изменения в индекс, необходимо использовать команду  `git add .`  Синтаксис команды:

```
git add .
```

Эта команда добавляет все измененные файлы в рабочей директории в индекс.

## git commit

Команда  `git commit`  используется для сохранения изменений, сделанных в вашем локальном репозитории, в истории коммитов. Каждый коммит в Git имеет уникальный идентификатор, дату и время коммита, имя автора, электронную почту и сообщение, описывающее изменения. Синтаксис команды:

```
git commit -m "<сообщение коммита>"
```

`сообщение коммита`  это краткое описание изменений, сделанных в коммите.

Основные флаги:

-   `-m`  означает message (сообщение)

Пример использования.

```
git commit -m "Добавлен новый файл README.md"
```

## git checkout

Команда  `git checkout`  в Git используется для переключения между ветками, проверки коммитов и отката изменений. Она позволяет переключаться между различными состояниями вашего репозитория.

Основные флаги:

-   `-b`  создать новую ветку и переключиться на нее. Например,  `git checkout -b new-branch`  создаст новую ветку с названием  `new-branch`  и переключится на нее
-   `-f`  принудительно перезаписывает локальные изменения, которые не были зафиксированы. Этот флаг используется только в крайних случаях
-   `-p`: позволяет просмотреть и выбрать конкретные изменения для восстановления
-   `<commit/branch>`: позволяет переключиться на определенный коммит или ветку

Пример использования.

Переключение на ветку:

```
git checkout main
```

Эта команда переключает вас на ветку "main".

Создание новой ветки и переключение на нее:

```
git checkout -b new-branch
```

Эта команда создает новую ветку с названием "new-branch" и переключает вас на нее.

Переключение на определенный коммит:

```
git checkout 2a3e8c9
```

Эта команда переключает вас на коммит с указанным идентификатором.

Отмена изменений в файле:

```
git checkout myfile.txt
```

Эта команда отменяет изменения в файле "myfile.txt" и восстанавливает его до последней зафиксированной версии.

Восстановление определенных изменений:

```
git checkout -p myfile.txt
```

Эта команда позволяет вам просмотреть изменения в файле "myfile.txt" и выбрать, какие из них восстановить.

## git branch

Команда  `git branch`  используется для просмотра, создания и удаления веток в репозитории Git. Ветка - это отдельная линия разработки, которая может включать в себя свой собственный набор коммитов.

Основные флаги:

-   `-a`  показывает все ветки включая удаленные
-   `-d` удаляет ветку, данная команда удаляет только те ветки, которые были слиты в текущую ветку
-   `-D`  удаляет ветку без проверки, были ли все её изменения слиты с текущей веткой
-   `-m`  переименовывает текущую ветку
-   `-r`  показывает все удаленные ветки

Примеры использования.

Просмотр списка веток:

```
git branch
```

Создание новой ветки:

```
git branch new-branch
```

Переименование текущей ветки:

```
git branch -m new-branch-name
```

Удаление ветки:

```
git branch -d branch-to-delete
```

Просмотр удаленных веток:

```
git branch -r
```

## git fetch

Команда  `git fetch`  используется для получения изменений из удаленного репозитория Git, но не вносит изменения в локальную ветку. Эта команда позволяет вам получить информацию о ветках и коммитах, которых еще нет в локальном репозитории. Синтаксис команды:

```
git fetch [<remote>] [<refspec>]
```

Основные флаги:

-   `remote`  имя удаленного репозитория Git (например, origin). Если не указан, Git использует имя origin по умолчанию
-   `refspec`  имена веток и тегов, которые вы хотите получить из удаленного репозитория. Если не указан, Git получает все ветки и теги

Примеры использования.

```
git fetch
```

Эта команда получает все изменения из удаленного репозитория Git, который связан с вашим локальным репозиторием. После выполнения этой команды вы можете выполнить команду  `git log origin/master`  для просмотра истории изменений в удаленной ветке  `master`.

```
git fetch origin feature-branch
```

Эта команда получает все изменения из удаленной ветки  `feature-branch`  в удаленном репозитории Git, связанном с вашим локальным репозиторием. После выполнения этой команды вы можете выполнить команду  `git log origin/feature-branch`  для просмотра истории изменений в удаленной ветке  `feature-branch`.

## git merge

Команда  `git merge`  используется для объединения изменений из одной ветки в другую. Она применяется для слияния изменений, которые были внесены в отдельной ветке, обычно для объединения фиксации ошибок или добавления функциональности в проект. Синтаксис команды:

```
git merge <имя ветки>
```

`имя ветки`  это имя ветки, изменения из которой вы хотите объединить в текущую ветку.

Примеры использования.

Сначала, вам нужно переключиться на ветку, в которую вы хотите объединить изменения:

```
git checkout master
```

Затем вы можете выполнить команду git merge, указав имя ветки, из которой вы хотите получить изменения:

```
git merge feature-branch
```

В этом примере мы объединяем изменения из ветки  `feature-branch`  в текущую ветку  `master`.

Основные флаги:

-   `--no-ff`отключает быстрое слияние, что создает коммит с объединением, даже если изменения можно было бы просто быстро применить
-   `--abort`  отменяет текущее слияние и возвращает репозиторий в предыдущее состояние

Пример использования флага  `--no-ff`:

```
git merge --no-ff feature-branch
```

В этом примере мы отключаем быстрое слияние и создаем новый коммит с объединением.

Пример использования флага  `--abort`:

```
git merge --abort
```

В этом примере мы отменяем текущее слияние и возвращаем репозиторий в предыдущее состояние.

## git rebase

Команда  `git rebase`  используется для перебазирования текущей ветки на другую ветку или на определенный коммит. Это означает, что изменения из исходной ветки будут применены поверх коммитов в целевой ветке или коммите.

Основные флаги:

-   `-i (или --interactive)`  запускает интерактивный режим, который позволяет изменять порядок, объединять или отбрасывать коммиты
-   `-m (или --merge)`  используется, когда нужно перебазировать ветку слияния
-   `--onto <branch>`: перебазирует текущую ветку на указанную ветку

Примеры использования.

Перебазирование текущей ветки на другую ветку:

```
git checkout feature-branch
git rebase main
```

В этом примере текущая ветка  `feature-branch`  перебазируется на ветку  `main`. Это означает, что изменения из ветки  `main`  будут применены поверх коммитов в ветке  `feature-branch`.

Перебазирование текущей ветки на определенный коммит:

```
git checkout feature-branch
git rebase abc123
```

В этом примере текущая ветка  `feature-branch`  перебазируется на коммит с хеш-кодом  `abc123`. Это означает, что изменения из этого коммита и всех коммитов после него будут применены поверх коммитов в ветке  `feature-branch`.

Использование интерактивного режима:

```
git checkout feature-branch
git rebase -i main
```

В этом примере запускается интерактивный режим, который позволяет изменять порядок, объединять или отбрасывать коммиты при перебазировании ветки  `feature-branch`  на ветку  `main`.

Перебазирование ветки слияния:

```
git checkout merge-branch
git rebase -m main
```

В этом примере ветка  `merge-branch`, являющаяся веткой слияния, перебазируется на ветку main. Опция  `-m`  используется для корректной обработки коммитов слияния.

## git revert

Команда  `git revert`  используется для отмены определенного коммита и создания нового коммита, который отменяет изменения предыдущего коммита. Это делает команду безопасной для использования в общем репозитории, поскольку она не изменяет историю коммитов. Синтаксис команды:

```
git revert <commit>
```

`commit`  это хэш-идентификатор коммита, который нужно отменить.

Основные флаги:

-   `--no-commit:` применить изменения, но не создавать новый коммит. Это позволяет вам проверить изменения перед тем, как закоммитить их
-   `-m parent-number:` используется, если коммит имеет несколько родительских коммитов (как в случае с объединением веток). Он указывает, какой из родительских коммитов следует использовать при выполнении операции отмены

Пример использования:

```
git log --oneline
d3b3d43 Commit C
786f7f8 Commit B
12556fa Commit A
git revert d3b3d43
```

Эта команда создаст новый коммит, который отменяет изменения, внесенные коммитом с хэш-идентификатором  `d3b3d43`.

Пример использования команды  `git revert`  с флагом  `--no-commit`:

```
git revert --no-commit d3b3d43
git status
On branch master
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
      modified:   file.txt
```

Эта команда отменяет изменения, внесенные коммитом с хэш-идентификатором  `d3b3d43`, и добавляет их в индекс. Но новый коммит не создается, пока не будет выполнена команда  `git commit`.

### Редкие команды

#### git difftool

Команда `git difftool` просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика `git diff`.

#### git reset

Команда `git reset`, как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель `HEAD` и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочей директории при использовании параметра `--hard`, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.

#### git rm

Команда `git rm` используется в Git для удаления файлов из индекса и рабочей директории. Она похожа на `git add` с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

#### git mv

Команда `git mv` — это всего лишь удобный способ переместить файл, а затем выполнить `git add`для нового файла и `git rm` для старого.

#### git clean

Команда `git clean` используется для удаления мусора из рабочей директории. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

#### git mergetool

Команда `git mergetool` просто вызывает внешнюю программу слияний, в случае если у вас возникли проблемы слияния.

#### git stash

Команда `git stash` используется для временного сохранения всех незакоммиченных изменений для очистки рабочей директории без необходимости коммитить незавершённую работу в новую ветку.

#### git tag

Команда `git tag` используется для задания постоянной метки на какой-либо момент в истории проекта. Обычно она используется для релизов.

#### git remote

Команда `git remote` служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например "origin", так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и `git remote` поможет добавлять, изменять и удалять их.

#### git archive

Команда `git archive` используется для упаковки в архив указанных коммитов или всего репозитория.

#### git submodule

Команда `git submodule` используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды `submodule` есть несколько под-команд — `add`, `update`, `sync` и др. — для управления такими репозиториями.

#### git show

Команда `git show` отображает объект в простом и человекопонятном виде. Обычно она используется для просмотра информации о метке или коммите.

#### git shortlog

Команда `git shortlog` служит для подведения итогов команды `git log`. Она принимает практически те же параметры, что и `git log`, но вместо простого листинга всех коммитов, они будут сгруппированы по автору.

#### git describe

Команда `git describe` принимает на вход что угодно, что можно трактовать как коммит (ветку, тег) и выводит более-менее человекочитаемую строку, которая не изменится в будущем для данного коммита. Это может быть использовано как более удобная, но по-прежнему уникальная, замена SHA-1.

#### git bisect

Команда `git bisect` — это чрезвычайно полезная утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска.

#### git blame

Команда `git blame` выводит перед каждой строкой файла SHA-1 коммита, последний раз менявшего эту строку и автора этого коммита. Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.

#### git grep

Команда `git grep` используется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях.


# Шпаргалка по Markdown

##  Форматирование текста

Это **жирный** текст и это __жирный текст__. 

А это *наклонный* текст и это тоже _наклонный_ текст.

А это **жирный внутри, которого _наклонный_** текст.

***Ещё пример одновременно жирного и наклонного текста.***
Чтобы зачеркнуть текст нужно использовать по две тильды ~ до и после текста (только в GFM).

Чтобы ~~зачеркнуть текст~~, нужно использовать по две тильды ~ до и после текста.

## Заголовки
Заголовки размечаются символом решетки в начале строки. Количество решеток соответсвует уровню заголовка.

# Заголовок первого уровня
## Заголовок h2
### Заголовок h3
#### Заголовок h4
##### Заголовок h5
###### Заголовок h6


## Неупорядоченные списки
Для разметки используются любые из символов -, +, *.

- элемент 1
- элемент 2
- элемент ...
элемент 1
элемент 2
элемент …
Вложенные пункты отделяются четырьмя пробелами.

* элемент 1
* элемент 2
    * вложенный элемент 2.1
    * вложенный элемент 2.2
* элемент ...
элемент 1
элемент 2
элемент 2.1
элемент 2.2
элемент …
Упорядоченные списки
1. элемент
2. элемент
    1. вложенный
    2. вложенный
3. элемент
элемент
элемент
вложенный
вложенный
элемент
На самом деле нумерация тут не важна, главное чтобы перед элементом списка стояла любая цифра с точкой.

1. элемент 1
1. элемент 2
1. элемент 3
1. элемент 4
Список из абзацев
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
* Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.

* Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.

* Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
Цитаты
Для разметки используется символ >.

> Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
>
> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.

Исходный код
В оригинальном Markdown код размечается 4 пробелами в начале каждой строки.

В GFM – по три апострофа до и после блока с кодом.

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>title</title>
</head>
<body>
	<p>content</p>
</body>
</html>
```
Инлайн код
Код внтури абзаца заключатся в апострофы. Пример: <html class="some-class">.

Код внтури абзаца заключатся в апострофы. Пример: `<html class="some-class">`.
Если внутри кода есть апостроф, код нужно заключить в двойные апострофы: There is a literal backtick (`) here.

Если внутри кода есть апостроф, то код надо обрамить двойными апострофами: ``There is a literal backtick (`) here.``
Горизонтальная черта
Создается тремя звездочками *** или тремя дефисами ---.

Ссылки
Пример [ссылки с title элементом](https://trofimovdigital.ru "title").
А это [ссылка без title](https://trofimovdigital.ru).
Пример ссылок с разметкой как у сносок.

[Пример][1] [нескольких][2] [ссылок][id] с разметкой как у сносок. [Короткая запись][] без указания id.

[1]: http://trofimovdigital.ru "Optional Title Here"
[2]: http://trofimovdigital.ru
[id]: http://trofimovdigital.ru (Optional Title Here)
[Короткая запись]: http://trofimovdigital.ru

Сноски можно располагать в любом месте документа.
Картинки
Картинка без alt текста.

![](//trofimovdigital.ru/150x150.jpg)
Картинка с альтом и тайтлом.

![Alt text](//trofimovdigital.ru/150x150.jpg "title")
Картинки «сноски» по аналогии с ссылками.

![Картинка][image1]
![Картинка][image2]
![Картинка][image3]

[image1]: //trofimovdigital.ru/250x100.jpg
[image2]: //trofimovdigital.ru/200x100.jpg
[image3]: //trofimovdigital.ru/150x100.jpg

Картинки-ссылки:
[![Alt text](//trofimovdigital.ru/150x100.jpg)](http://trofimovdigital.ru/)
Таблицы
В оригинальном Markdown нет разметки для таблиц, но есть в GitHub Flavored Markdown.

First Header  | Second Header
------------- | -------------
Content Cell  | Content Cell
Content Cell  | Content Cell
Можно управлять выравниванием столбцов используя символ двоеточия. Ещё можно использовать ссылки, наклонный, жирный или зачеркнутый текст.

| Left-Aligned  | Center Aligned  |      Right Aligned    |
|:------------- |:---------------:| ---------------------:|
| Content Cell  | Content Cell    | **bold**              |
| Content Cell  | Content Cell    | ~~strikethrough~~     |
| Content Cell  | Content Cell    | [link](https://ya.ru) |
Ссылки
Официальное руководство по синтаксису Markdown
Basic writing and formatting syntax on GitHub
Markdown на Википедии
Шпаргалка по Markdown
Онлайн Markdown редактор (на GitHub)
Онлайн Markdown редактор
10-минутный интерактивный туториал
